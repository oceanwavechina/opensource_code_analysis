# Ice 中 Node 是如何管理service的

1. 当我们通过 icegridadmin 中 的 start/stop/disable/enable 管理 server 时，Ice 内部都发生了什么，各个组件之间是如何交互的

2. 对于 server 的异常退出，Ice是如何感知到的

3. 问什么运行中的 server ，异常退出时，Ice可以重新启动；而 start 失败的 server 确被标记为 disable


## 1.  icegridadmin, registry, node, server 四个角色
----

在分析这四个角色之间的关系之前，先引入一个 AdminSession (src/IceGrid/AdminSession.h) 的概念。

* 这个东西可以理解成是 icegridadmin 和 registry 之间的交互通道。(在 registry 有多个副本的情况下，可能会连到 slave 上边(比如 slave 配置到了第一个，或是 master 挂了)，此时在 slave 上边只能执行读操作，也就是不能修改 registry 的数据库)

* 通道有了，那实现具体的接口就在 slice/IceGrid/Admin.ice 接口文件里边, 这个接口文件的 client 端(AdminPrx) 就是 icegridadmin, 而 server 端(AdminObject) 则在 src/IceGrid/AdminI.h 里边，server端的这个实现对象则在我们的 AdminSession 里边。

这样 icegridadmin 和 registry 之间的交互关系就有了： 通道 和 调用方法


###  1.1  icegridadmin


icegridadmin 的入口文件是 ice-3.7.2/cpp/src/IceGrid/Client.cpp。

icegridadmin 命令的语法定义和解析，用了 Bison parser 语法分析器。

最终的接口调用在 ice-3.7.2/cpp/src/IceGrid/Parser.h 里边， 以 " start server xxx" 为例， 经过语法解析后，调用的是 ```void Parser::startServer()``` 这个函数, 最终是调用 AdminPrx 的 startServer 方法, 直接到达了 registry（注意，这里的 AdminPrx 对象 是在 AdminSessionPrx 对象里边获取了，如上边介绍 AdminSession 概念所说）。

作为 client 端，其实具体的业务不太多， 主要就是根据 command 分发调用

于是 icegridadmin 和 registry 之间的关系是这样的, 通道是 adminsession， 二者之间的通信是通过 Admin.ice 接口交互

```

                                    -------- adminsession --------

        icegridadmin(AdminPrx)              >  Admin.ice  >                registry(AdminI)
                                    
                                    -------- adminsession --------
```
