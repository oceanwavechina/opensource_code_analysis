# 内核如何加载和启动一个可执行程序

一个可执行文件的运行大致分两步：

1. 创建一个进程: 也就是通过 fork
2. 把可执行文件加载到所创建的进程, 即在子进程调用 exe() 系列函数

我们之前看过[一些 fork 相关实现](https://gitee.com/oceanwave/opensource_code_analysis/blob/master/linux-4.19.180/pthread%20%E5%88%9B%E5%BB%BA%E4%BA%86%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%EF%BC%9F.md)。这篇我们主要看 exe() 系列函数的实现。这系列函数不痛的地方只是传入的参数不同，内部实现是一样的。先看看 man 手册中对这一些系列函数的描述：

> The exec family of functions replaces the current process image with a new process image.

我们从 execv 函数入手。

<br>

## 1. execv 调用栈
----
<br>

我们先大致看一下 execv(```fs/exec.c:1972```) 函数的调用栈，大体上看看都有那些步骤。

``` cpp
SYSCALL_DEFINE3(execve)
    |
    |-> do_execve(getname(filename), argv, envp)
        |
        |-> do_execveat_common(AT_FDCWD, filename, argv, envp, 0)
            |
            |-> __do_execve_file(fd, filename, argv, envp, flags, NULL)
                |
                |-> // 检查当前用户下的进程有没有到达上限
                |
                |-> unshare_files() //  相当于备份原有一打开的文件列表
                |
                |-> prepare_bprm_creds() // 准备运行文件所需的权限信息
                |
                |-> do_open_execat(fd, filename, flags) // 打开可执行文件
                |
                |-> sched_exec()    // 为当前 task 选择cpu
                |
                |-> bprm_mm_init(bprm)  // 初始化 memory manager， 相当于重置了虚拟地址空间
                |
                |-> copy_xxxx() // 准备程序运行需要的参数等
                |
                |-> exec_binprm()   // 运行可执行文件 **
                |
                |-> // 释放资源等
```

可以看到核心逻辑是在 ```exec_binprm()``` 这个函数:

``` cpp
exec_binprm(bprm)
    |
    |-> search_binary_handler(bprm)
        |
        |-> list_for_each_entry(fmt, &formats, lh) { fmt->load_binary(bprm); }
```

这里是根据文件格式，找到对应的 loader， 然后 load 文件。

所有可用的可执行文件格式都是通过 ```register_binfmt(struct linux_binfmt *fmt) (include/linux/binfmts.h:106)``` 注册的。

我们这里以 elf (```fs/binfmt_elf.c```) 为例


<br>

## 2. ELF 文件结构和加载过程
----
<br>

我们先看下 ELF 的文件结构：

![elf_layout](resources/ELF_Executable_and_Linkable_Format_diagram_by_Ange_Albertini.png)


elf 文件的接口函数如下(```fs/binfmt_elf.c:93```)：

``` cpp
static struct linux_binfmt elf_format = {
	.module		= THIS_MODULE,
	.load_binary	= load_elf_binary,
	.load_shlib	= load_elf_library,
	.core_dump	= elf_core_dump,
	.min_coredump	= ELF_EXEC_PAGESIZE,
};
```

其中 elf header 的例子可以 [看这里](resources/elf_header_info.txt)

所以其加载函数也就是 ```load_elf_binary```:
``` cpp
static int load_elf_binary(struct linux_binprm *bprm)
{
    // 获取文件头
    // typedef struct elf64_phdr {
    //     Elf64_Word p_type;
    //     Elf64_Word p_flags;
    //     Elf64_Off p_offset;		/* Segment file offset */
    //     Elf64_Addr p_vaddr;		/* Segment virtual address */
    //     Elf64_Addr p_paddr;		/* Segment physical address */
    //     Elf64_Xword p_filesz;		/* Segment size in file */
    //     Elf64_Xword p_memsz;		/* Segment size in memory */
    //     Elf64_Xword p_align;		/* Segment alignment, file & memory */
    // } Elf64_Phdr;
	elf_phdata = load_elf_phdrs(&loc->elf_ex, bprm->file);
	if (!elf_phdata)
		goto out;


	// 把程序需要执行的参数压到栈里边
	retval = setup_arg_pages(bprm, randomize_stack_top(STACK_TOP),
				 executable_stack);
	if (retval < 0)
		goto out_free_dentry;
	
    // 告诉内存管理当前的栈的 top
	current->mm->start_stack = bprm->p;

	// 把 elf 文件的内容映射到内存
	for(i = 0, elf_ppnt = elf_phdata;
	    i < loc->elf_ex.e_phnum; i++, elf_ppnt++) {

		error = elf_map(bprm->file, load_bias + vaddr, elf_ppnt,
				elf_prot, elf_flags, total_size);
	}

    // 计算实际的地址
	loc->elf_ex.e_entry += load_bias;
	elf_bss += load_bias;
	elf_brk += load_bias;
	start_code += load_bias;
	end_code += load_bias;
	start_data += load_bias;
	end_data += load_bias;

    // 映射 bbs
	retval = set_brk(elf_bss, elf_brk, bss_prot);


    // 运行程序
	finalize_exec(bprm);
	start_thread(regs, elf_entry, bprm->p);
}
```

其中运行程序就是设置好当前cpu 各个寄存器的值，比如
``` cpp
static void
start_thread_common(struct pt_regs *regs, unsigned long new_ip,
		    unsigned long new_sp,
		    unsigned int _cs, unsigned int _ss, unsigned int _ds)
{
    // 加载数据段
	loadsegment(fs, 0);
	loadsegment(es, _ds);
	loadsegment(ds, _ds);
	load_gs_index(0);

    // sp+ss 操作栈
    // cs+ip 读取代码指令
	regs->ip		= new_ip;
	regs->sp		= new_sp;
	regs->cs		= _cs;  
	regs->ss		= _ss;
	regs->flags		= X86_EFLAGS_IF;
	force_iret();
}
```

exec 的本质过程就是把可执行文件中的各个 segment 加载到内存中，然后设置好程序入口(cs,ip 等寄存器)。转移cpu控制权。

<br>

## 3. TODO
----
<br>

1. 当内核设置程序入口的时候，是我们程序中的main函数吗？

2. 静态变量初始化对应内核 中的哪部分逻辑 ?

<br><br><br>

## 参考资料
----
<br>

* [The Design and Implementation of Userland Exec](https://grugq.github.io/docs/ul_exec.txt)
* [Linux内核如何装载和启动一个可执行程序](https://www.cnblogs.com/inevermore/p/4438944.html)
* [The 101 of ELF files on Linux: Understanding and Analysis](https://linux-audit.com/elf-binaries-on-linux-understanding-and-analysis/)
* [ELF文件详解—初步认识](https://blog.csdn.net/daide2012/article/details/73065204)
* [Linux Inside](https://0xax.gitbooks.io/linux-insides/content/SysCall/linux-syscall-4.html)